/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
#include <thrift/lib/cpp2/protocol/DebugProtocol.h>
#include <thrift/lib/cpp2/protocol/VirtualProtocol.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>
#include <boost/operators.hpp>




namespace cpp2 {

class GossipInterface;
class GossipNode;
class GossipNodeInstance;
class GossipState;

enum class GossipStatus {
  DOWN_TO_UP = 8,
  UP_TO_DOWN = 4,
  UP = 2,
  DOWN = 1
};

extern const std::map<GossipStatus, const char*> _GossipStatus_VALUES_TO_NAMES;
extern const std::map<const char*, GossipStatus, apache::thrift::ltstr> _GossipStatus_NAMES_TO_VALUES;

} // cpp2
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::cpp2::GossipStatus>::findName( ::cpp2::GossipStatus value);
template <> bool TEnumTraitsBase< ::cpp2::GossipStatus>::findValue(const char* name,  ::cpp2::GossipStatus* outValue);

template <> constexpr  ::cpp2::GossipStatus TEnumTraits< ::cpp2::GossipStatus>::min() {
  return  ::cpp2::GossipStatus::DOWN;
}

template <> constexpr  ::cpp2::GossipStatus TEnumTraits< ::cpp2::GossipStatus>::max() {
  return  ::cpp2::GossipStatus::DOWN_TO_UP;
}

}} // apache::thrift
namespace cpp2 {

enum class AddressFamily {
  IPV6 = 2,
  IPV4 = 1
};

extern const std::map<AddressFamily, const char*> _AddressFamily_VALUES_TO_NAMES;
extern const std::map<const char*, AddressFamily, apache::thrift::ltstr> _AddressFamily_NAMES_TO_VALUES;

} // cpp2
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::cpp2::AddressFamily>::findName( ::cpp2::AddressFamily value);
template <> bool TEnumTraitsBase< ::cpp2::AddressFamily>::findValue(const char* name,  ::cpp2::AddressFamily* outValue);

template <> constexpr  ::cpp2::AddressFamily TEnumTraits< ::cpp2::AddressFamily>::min() {
  return  ::cpp2::AddressFamily::IPV4;
}

template <> constexpr  ::cpp2::AddressFamily TEnumTraits< ::cpp2::AddressFamily>::max() {
  return  ::cpp2::AddressFamily::IPV6;
}

}} // apache::thrift
namespace cpp2 {

class GossipInterface : private boost::totally_ordered<GossipInterface> {
 public:

  GossipInterface() :
      port(0) {}
  // FragileConstructor for use in initialization lists only

  GossipInterface(apache::thrift::FragileConstructor, std::string address__arg, int32_t port__arg) :
      address(std::move(address__arg)),
      port(std::move(port__arg)) {}

  GossipInterface(GossipInterface&&) = default;

  GossipInterface(const GossipInterface&) = default;

  GossipInterface& operator=(GossipInterface&&) = default;

  GossipInterface& operator=(const GossipInterface&) = default;
  void __clear();

  virtual ~GossipInterface() throw() {}

  std::string address;
  int32_t port;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      address = false;
      port = false;
    }

    bool address;
    bool port;
  } __isset;
  bool operator==(const GossipInterface& rhs) const;

  bool operator < (const GossipInterface& rhs) const {
    if (!(address == rhs.address)) {
      return address < rhs.address;
    }
    if (!(port == rhs.port)) {
      return port < rhs.port;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GossipInterface& a, GossipInterface& b);

} // cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::cpp2::GossipInterface>::clear( ::cpp2::GossipInterface* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipInterface>::write(Protocol* proto, const  ::cpp2::GossipInterface* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipInterface>::read(Protocol* proto,   ::cpp2::GossipInterface* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipInterface>::serializedSize(Protocol* proto, const  ::cpp2::GossipInterface* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipInterface>::serializedSizeZC(Protocol* proto, const  ::cpp2::GossipInterface* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace cpp2 {

class GossipNode : private boost::totally_ordered<GossipNode> {
 public:

  GossipNode() {}
  // FragileConstructor for use in initialization lists only

  GossipNode(apache::thrift::FragileConstructor, std::string guid__arg, std::set< ::cpp2::GossipInterface> interfaces__arg,  ::cpp2::GossipStatus currentStatus__arg) :
      guid(std::move(guid__arg)),
      interfaces(std::move(interfaces__arg)),
      currentStatus(std::move(currentStatus__arg)) {}

  GossipNode(GossipNode&&) = default;

  GossipNode(const GossipNode&) = default;

  GossipNode& operator=(GossipNode&&) = default;

  GossipNode& operator=(const GossipNode&) = default;
  void __clear();

  virtual ~GossipNode() throw() {}

  std::string guid;
  std::set< ::cpp2::GossipInterface> interfaces;
   ::cpp2::GossipStatus currentStatus;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      guid = false;
      interfaces = false;
      currentStatus = false;
    }

    bool guid;
    bool interfaces;
    bool currentStatus;
  } __isset;
  bool operator==(const GossipNode& rhs) const;

  bool operator < (const GossipNode& rhs) const {
    if (!(guid == rhs.guid)) {
      return guid < rhs.guid;
    }
    if (!(interfaces == rhs.interfaces)) {
      return interfaces < rhs.interfaces;
    }
    if (!(currentStatus == rhs.currentStatus)) {
      return currentStatus < rhs.currentStatus;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GossipNode& a, GossipNode& b);

} // cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::cpp2::GossipNode>::clear( ::cpp2::GossipNode* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNode>::write(Protocol* proto, const  ::cpp2::GossipNode* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNode>::read(Protocol* proto,   ::cpp2::GossipNode* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNode>::serializedSize(Protocol* proto, const  ::cpp2::GossipNode* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNode>::serializedSizeZC(Protocol* proto, const  ::cpp2::GossipNode* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace cpp2 {

class GossipNodeInstance : private boost::totally_ordered<GossipNodeInstance> {
 public:

  GossipNodeInstance() :
      updateTimestamp(0) {}
  // FragileConstructor for use in initialization lists only

  GossipNodeInstance(apache::thrift::FragileConstructor, int64_t updateTimestamp__arg,  ::cpp2::GossipNode node__arg) :
      updateTimestamp(std::move(updateTimestamp__arg)),
      node(std::move(node__arg)) {}

  GossipNodeInstance(GossipNodeInstance&&) = default;

  GossipNodeInstance(const GossipNodeInstance&) = default;

  GossipNodeInstance& operator=(GossipNodeInstance&&) = default;

  GossipNodeInstance& operator=(const GossipNodeInstance&) = default;
  void __clear();

  virtual ~GossipNodeInstance() throw() {}

  int64_t updateTimestamp;
   ::cpp2::GossipNode node;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      updateTimestamp = false;
      node = false;
    }

    bool updateTimestamp;
    bool node;
  } __isset;
  bool operator==(const GossipNodeInstance& rhs) const;

  bool operator < (const GossipNodeInstance& rhs) const {
    if (!(updateTimestamp == rhs.updateTimestamp)) {
      return updateTimestamp < rhs.updateTimestamp;
    }
    if (!(node == rhs.node)) {
      return node < rhs.node;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GossipNodeInstance& a, GossipNodeInstance& b);

} // cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::cpp2::GossipNodeInstance>::clear( ::cpp2::GossipNodeInstance* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNodeInstance>::write(Protocol* proto, const  ::cpp2::GossipNodeInstance* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNodeInstance>::read(Protocol* proto,   ::cpp2::GossipNodeInstance* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNodeInstance>::serializedSize(Protocol* proto, const  ::cpp2::GossipNodeInstance* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipNodeInstance>::serializedSizeZC(Protocol* proto, const  ::cpp2::GossipNodeInstance* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace cpp2 {

class GossipState : private boost::totally_ordered<GossipState> {
 public:

  GossipState() {}
  // FragileConstructor for use in initialization lists only

  GossipState(apache::thrift::FragileConstructor,  ::cpp2::GossipNodeInstance sender__arg, std::set< ::cpp2::GossipNodeInstance> liveNodes__arg, std::set< ::cpp2::GossipNodeInstance> suspectNodes__arg, std::set< ::cpp2::GossipNodeInstance> deadNodes__arg) :
      sender(std::move(sender__arg)),
      liveNodes(std::move(liveNodes__arg)),
      suspectNodes(std::move(suspectNodes__arg)),
      deadNodes(std::move(deadNodes__arg)) {}

  GossipState(GossipState&&) = default;

  GossipState(const GossipState&) = default;

  GossipState& operator=(GossipState&&) = default;

  GossipState& operator=(const GossipState&) = default;
  void __clear();

  virtual ~GossipState() throw() {}

   ::cpp2::GossipNodeInstance sender;
  std::set< ::cpp2::GossipNodeInstance> liveNodes;
  std::set< ::cpp2::GossipNodeInstance> suspectNodes;
  std::set< ::cpp2::GossipNodeInstance> deadNodes;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      sender = false;
      liveNodes = false;
      suspectNodes = false;
      deadNodes = false;
    }

    bool sender;
    bool liveNodes;
    bool suspectNodes;
    bool deadNodes;
  } __isset;
  bool operator==(const GossipState& rhs) const;

  bool operator < (const GossipState& rhs) const {
    if (!(sender == rhs.sender)) {
      return sender < rhs.sender;
    }
    if (!(liveNodes == rhs.liveNodes)) {
      return liveNodes < rhs.liveNodes;
    }
    if (!(suspectNodes == rhs.suspectNodes)) {
      return suspectNodes < rhs.suspectNodes;
    }
    if (!(deadNodes == rhs.deadNodes)) {
      return deadNodes < rhs.deadNodes;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GossipState& a, GossipState& b);

} // cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::cpp2::GossipState>::clear( ::cpp2::GossipState* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipState>::write(Protocol* proto, const  ::cpp2::GossipState* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipState>::read(Protocol* proto,   ::cpp2::GossipState* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipState>::serializedSize(Protocol* proto, const  ::cpp2::GossipState* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::cpp2::GossipState>::serializedSizeZC(Protocol* proto, const  ::cpp2::GossipState* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace cpp2 {

} // cpp2